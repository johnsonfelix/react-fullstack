generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}


datasource d {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}


model User {
  id               String     @id @default(cuid())
  username         String     @unique
  password         String
  email            String?    @unique
  type             String
  profileCompleted Boolean    @default(false)
  createdAt        DateTime   @default(now()) @map(name: "created_at")
  updatedAt        DateTime   @updatedAt @map(name: "updated_at")

  supplier         Supplier?  @relation("UserSupplier", fields: [supplierId], references: [id])
  supplierId       String?    @unique

  @@map(name: "users")
}

model Supplier {
  id                    String    @id @default(cuid())
  
  // Company Details (Step 1)
  companyName           String
  registrationEmail     String    @unique
  website               String?
  country               String
  tradeLicenseNumber    String?
  taxRegistrationNumber String?
  organizationType      String
  supplierType          String
  noteToApprover        String?
  profileAttachments    String[]  // Array of file URLs
  
  // Relationships
  contacts              Contact[]
  addresses             Address[]
  businessDocuments     BusinessDocument[]
  bankAccounts          BankAccount[]
  questionnaireResponse QuestionnaireResponse?
  questionnaireAnswers  QuestionnaireAnswer[]
  user                  User?        @relation("UserSupplier")

  registrationStatus     String?  // e.g. "DRAFT", "FORM_SUBMITTED", "APPROVED"
  registrationReference  String?  // unique/visible id for the user
  registrationSubmittedAt DateTime?
  
  // Add these relation fields to satisfy Category and ProcurementRequest relations:
  productCategories     SupplierCategory[]
  procurementRequests   ProcurementRequest[]     @relation("ProcurementRequestSuppliers")
  
  // Metadata
  status                String    @default("pending") // pending, approved, rejected
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  submittedAt           DateTime?
  
  @@map("suppliers")
}

// Step 2: Contacts
model Contact {
  id                      String   @id @default(cuid())
  firstName               String
  lastName                String
  email                   String
  designation             String?
  countryCode             String
  mobile                  String
  isAdministrativeContact Boolean  @default(false)
  needsUserAccount        Boolean  @default(false)
  phone                   String?  // ADD THIS LINE
  ext                     String?  // ADD THIS LINE
  
  supplier                Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId              String
  
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  
  @@map("contacts")
}

// Step 3: Addresses
model Address {
  id          String   @id @default(cuid())
  type        String
  line1       String
  line2       String?
  line3       String?
  city        String
  state       String
  postalCode  String
  country     String
  usage              Json? 
  associatedContacts Json? 
  
  supplier    Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId  String
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("addresses")
}

// Step 4: Business Documents
model BusinessDocument {
  id                  String    @id @default(cuid())
  classification      String    // e.g., "INSURANCE", "CERTIFICATION"
  subClassification   String?
  certifyingAgency    String?
  certificateNumber   String?
  certificateStartDate DateTime?
  certificateEndDate  DateTime?
  otherCertifyingAgency String?
  notes               String?
  attachments         String[]  // Array of file URLs
  
  supplier            Supplier  @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId          String
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  @@map("business_documents")
}

// Step 5: Bank Accounts
model BankAccount {
  id            String   @id @default(cuid())
  country       String
  currency      String
  accountType   String 
  bankName      String
  accountNumber String
  accountHolder String
  bankBranch    String? 
  iban          String?
  swiftCode     String?
  
  supplier      Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId    String
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("bank_accounts")
}

//  model Category {
//    id              String      @id @default(cuid())
//    name            String
//    createdAt       DateTime    @default(now()) @map(name: "created_at")
//    updatedAt       DateTime    @updatedAt @map(name: "updated_at")
//  
//    // Self-referencing fields
//    parentCategoryId String?     
//    parentCategory   Category?   @relation("SubCategories", fields: [parentCategoryId], references: [id])
//    subcategories    Category[]  @relation("SubCategories")
//  
//    suppliers        Supplier[]  @relation("SupplierCategories")
//  }

// Step 6: Product Categories
model ProductCategory {
  id          String             @id @default(cuid())
  name        String
  parentId    String?
  description String?
  parent      ProductCategory?   @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ProductCategory[]  @relation("CategoryHierarchy")

  suppliers   SupplierCategory[] // join records

  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@map("product_categories")
}

// join table already present in your schema — leave as-is
model SupplierCategory {
  id              String          @id @default(cuid())

  supplier        Supplier        @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId      String

  productCategory ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId      String

  createdAt       DateTime        @default(now())

  @@unique([supplierId, categoryId])
  @@map("supplier_categories")
}

// Step 7: Questionnaire

 model QuestionnaireTemplate {
   id          String                  @id @default(cuid())
   name        String
   description String?
   isActive    Boolean                 @default(true)
   // each template belongs to a category (required per your request)
   categoryId  String
   category    QuestionnaireCategory   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
   questions   QuestionnaireQuestion[]
   createdAt   DateTime                @default(now())
   updatedAt   DateTime                @updatedAt

   @@map("questionnaire_templates")
 }

 model QuestionnaireCategory {
   id         String                 @id @default(cuid())
   name       String
   order      Int                    @default(0)
   // a category may have many templates
   templates  QuestionnaireTemplate[]
   // questions can also reference this category (optional)
   questions  QuestionnaireQuestion[] 

   createdAt  DateTime               @default(now())
   updatedAt  DateTime               @updatedAt

   @@map("questionnaire_categories")
 }

// Questions in a template
model QuestionnaireQuestion {
  id               String                @id @default(cuid())
  text             String
  description      String?
  type             String                @default("text")
  required         Boolean               @default(false)
  order            Int                   @default(0)

  options          Json?
  validation       Json?

  // attachments array (fixed)
  attachments      String[]              @default([])

  // category relation (optional)
  categoryId       String?
  category         QuestionnaireCategory? @relation(fields: [categoryId], references: [id])

  // template relation
  templateId       String
  template         QuestionnaireTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  // nested/sub-question self-relation
  parentQuestionId String?
  parentQuestion   QuestionnaireQuestion? @relation("SubQ", fields: [parentQuestionId], references: [id])
  subQuestions     QuestionnaireQuestion[] @relation("SubQ")

  answers          QuestionnaireAnswer[]

  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt

  @@map("questionnaire_questions")
}

// Supplier's answers
model QuestionnaireAnswer {
  id         String                @id @default(cuid())
  answer     Json                  // Flexible storage for any answer type
  
  questionId String
  question   QuestionnaireQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  supplierId String
  supplier   Supplier              @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt
  
  @@unique([questionId, supplierId])
  @@map("questionnaire_answers")
}

model QuestionnaireResponse {
  id                            String   @id @default(cuid())
  
  // Declarations
  hasQualityManagementSystem    Boolean  @default(false)
  hasEnvironmentalCertification Boolean  @default(false)
  hasHealthSafetyCertification  Boolean  @default(false)
  acceptsTermsAndConditions     Boolean  @default(false)
  
  // Minimum Required Documents
  hasBusinessLicense            Boolean  @default(false)
  hasTaxCertificate             Boolean  @default(false)
  hasInsuranceCertificate       Boolean  @default(false)
  
  // F&B Specific (if applicable)
  hasFoodSafetyCertificate      Boolean  @default(false)
  hasHalalCertificate           Boolean  @default(false)
  hasOrganicCertificate         Boolean  @default(false)
  
  // Additional responses
  additionalNotes               String?
  
  supplier                      Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  supplierId                    String   @unique
  
  createdAt                     DateTime @default(now())
  updatedAt                     DateTime @updatedAt
  
  @@map("questionnaire_responses")
}


model Currency {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model Incoterms {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model ServiceType {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model Carrier {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}


model Payment {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model Shipping {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model Uom {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model Urgency {
  id        String      @id @default(cuid())
  name      String
  createdAt DateTime     @default(now()) @map(name: "created_at")
  updatedAt DateTime     @updatedAt @map(name: "updated_at")
}

model BRFQ {
  id                    String   @id @default(uuid())
  rfqId                 String   @unique
  title                 String
  openDate              DateTime?
  closeDate             DateTime
  closeTime             DateTime
  needByDate            DateTime?
  preferredDeliveryTime String?
  requester             String?
  shippingAddress       String?
  paymentProcess        String
  currency              String
  shippingType          String?
  carrier               String?
  urgency               String?
  notesToSupplier       String?
  incoterms             String?
  origin                String?
  currentPrice          String?
  targetPrice           String?
  prValue               String?
  productSpecification  String?
  customerCategory      String[]
  suppliersSelected     Json?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  items                 RequestItem[]
  suppliers             String[]

  attachmentPath        String?

  // ✅ Add this reverse relation
  quotes                Quote[]  @relation("BRFQToQuotes")
  modificationRequests  ModificationRequest[]
  award   Award[]


  pauseRequests  PauseRequest[]   // all pause requests created for this BRFQ
  pauseActions   PauseAction[]    // chronological pause/resume actions

  publishOnApproval     Boolean  @default(false)   // if true, will be published automatically when approved
  approvalStatus        String   @default("none")  // "none" | "pending" | "approved" | "rejected"
  approvalRequestedBy   String?                        // user id / username who sent for approval
  approvalRequestedAt   DateTime?
  approvedBy            String?
  approvedAt            DateTime?
  approvalNote          String?                        // optional note from approver when approving/rejecting
  published             Boolean  @default(false)      // whether RFQ is published (visible to suppliers)
  status                String?  
}



model RequestItem {
  id             String   @id @default(uuid())
  brfqId         String
  internalPartNo String?
  manufacturer   String?
  mfgPartNo      String?
  description    String
  uom            String   // store name directly
  quantity       Int

  brfq           BRFQ     @relation(fields: [brfqId], references: [id], onDelete: Cascade)
}

model Quote {
  id               String   @id @default(uuid())
  supplierQuoteNo  String
  validFor         String
  currency         String
  shipping         String
  comments         String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  rfqId            String
  supplierId       String

  // ✅ Name the relation explicitly to match BRFQ
  rfq              BRFQ     @relation("BRFQToQuotes", fields: [rfqId], references: [id])
  items            QuoteItem[]
}

model QuoteItem {
  id             String   @id @default(uuid())
  quoteId        String
  quote          Quote    @relation(fields: [quoteId], references: [id])

  supplierPartNo String
  deliveryDays   String
  unitPrice      String
  qty            String
  uom            String
  cost           Float
}

model ProcurementItem {
  id              String               @id @default(cuid())
  title           String
  quantity        Int
  price           Int?
  manufacturerPartNo   String?
  uom             String?
  procurementId   String
  procurement     ProcurementRequest   @relation(fields: [procurementId], references: [id], onDelete: Cascade)
}

model ProcurementRequest {
  id          String                    @id @default(cuid())
  title       String
  description String?
  requestType String
  category    String
  address     String
  scopeOfWork ScopeOfWorkDeliverable[]
  status      String                    @default("draft")
  evaluationSections EvaluationSection[]
  evaluationDetails Json?
  items       ProcurementItem[]
  questions   Question[] 
  aiQuestions Json?
  additionalFields Json?
  suppliers   Supplier[] @relation("ProcurementRequestSuppliers")
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt
}

model ScopeOfWorkDeliverable {
  id              String          @id @default(cuid())
  title           String
  description     String?
  procurementId   String
  userInstruction String?
  procurement     ProcurementRequest @relation(fields: [procurementId], references: [id], onDelete: Cascade)
  questions       Question[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model Question {
  id                String    @id @default(cuid())
  text              String
  type              String    @default("text") // "text", "yes_no", etc.
  required          Boolean   @default(false)
  quantity          Int?
  uom               String?   // unit of measure
  benchmark         String?

  deliverableId     String
  deliverable       ScopeOfWorkDeliverable @relation(fields: [deliverableId], references: [id])

  rfpId             String?
  rfp               ProcurementRequest? @relation(fields: [rfpId], references: [id], onDelete: Cascade)

  // ✅ Parent-child linking for conditional sub-questions
  parentQuestionId  String?
  parentQuestion    Question? @relation("SubQuestions", fields: [parentQuestionId], references: [id])
  subQuestions      Question[] @relation("SubQuestions")

  // ✅ For conditionals
  conditionOperator String?   // "equal to", "not equal to"
  conditionValue    String?   // "Yes", "No"

  // ✅ NEW: To persist Service Question Name for correct restoration
  serviceName       String?   // "Cleaning", "Maintenance", etc.
  serviceType       String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

model EvaluationSection {
  id                     String            @id @default(cuid())
  title                  String
  weightPercentage       Int
  useLineLevelWeighting  Boolean           @default(false)
  procurementRequest     ProcurementRequest @relation(fields: [procurementRequestId], references: [id])
  procurementRequestId   String
  items                  EvaluationItem[]
}

model EvaluationItem {
  id                   String           @id @default(cuid())
  description          String
  weightPercentage     Int
  evaluationSection    EvaluationSection @relation(fields: [evaluationSectionId], references: [id])
  evaluationSectionId  String
}

model Otp {
  id        String   @id @default(cuid())
  email     String   @unique
  otp       String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Approval workflow models
model ApprovalRule {
  id              String               @id @default(cuid())
  name            String
  description     String?              // optional human-readable note
  criteria        Json?                // flexible criteria JSON: { minValue, maxValue, categories, responseVisibility, ... }
  slaHours        Int?                 // SLA in hours
  escalationEmail String?              // email to escalate to when SLA breaches
  autoPublish     Boolean   @default(false)
  active          Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  approvers       ApprovalApprover[]
  history         ApprovalHistory[]

  @@map("approval_rules")
}

model ApprovalApprover {
  id        String   @id @default(cuid())
  rule      ApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  ruleId    String
  approverId String?   // optional user id or role id in your system
  role       String?   // e.g. "Procurement Head"
  email      String?
  order      Int       @default(1)   // sequence order for approvals
  isParallel Boolean   @default(false)
  createdAt  DateTime  @default(now())

  @@map("approval_approvers")
  @@index([ruleId])
}

model ApprovalHistory {
  id          String   @id @default(cuid())
  ruleId      String
  rule        ApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  action      String   // "requested" | "approved" | "rejected" | "escalated"
  byUser      String?  // user id or name
  note        String?
  createdAt   DateTime @default(now())

  @@map("approval_history")
  @@index([ruleId])
}

model ModificationRequest {
  id              String   @id @default(cuid())
  brfqId          String
  brfq            BRFQ     @relation(fields: [brfqId], references: [id], onDelete: Cascade)
  requestedBy     String
  requestedAt     DateTime @default(now())
  requestedFields String[]  // e.g. ["closeDateTime","items"]
  summary         Json     // structured diff: { closeDateTime: { from:..., to:... }, items: { from:[], to:[] }, ... }
  note            String?
  status          String   @default("pending") // pending|approved|rejected
  processedBy     String?
  processedAt     DateTime?
  createdAt       DateTime @default(now())

  approvals       ModificationApprovalHistory[]  // history
}

model ModificationApprovalHistory {
  id             String   @id @default(cuid())
  modificationId String
  modification   ModificationRequest @relation(fields: [modificationId], references: [id], onDelete: Cascade)
  action         String   // approve | reject
  actedBy        String
  actedAt        DateTime @default(now())
  note           String?
}

model AdminModificationConfig {
  id               String   @id @default(cuid())
  editableFields   Json     // e.g. { closeDateTime: true, items: true, targetPrice: true, visibility: false }
  approverList     Json?    // array of approvers with order and parallel flag
  notifySuppliers  Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model ModificationRules {
  id                         String   @id @default(cuid())
  name                       String?              // e.g. "Default Modification Rules"
  fields                     Json                 // array of FieldRule objects
  approvers                  Json?                // array of approver objects (optional)
  notifyAllSuppliersOnChange Boolean  @default(true)
  supplierNotificationSubject String?              // optional template subject
  supplierNotificationBody    String?              // optional template body
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
}

/// Pause/pause-request models
model PauseReason {
  id        String   @id @default(cuid())
  key       String   @unique           // machine key e.g. "technical_issue"
  label     String                       // human label e.g. "Technical Issue"
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PauseRequest {
  id            String   @id @default(cuid())
  brfqId        String
  brfq          BRFQ     @relation(fields: [brfqId], references: [id], onDelete: Cascade)
  requestedBy   String
  reasonId      String?
  reasonText    String?
  status        String   @default("pending")
  processedBy   String?
  processedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // history relation — PauseAction must have a field linking back
  history       PauseAction[]
}

model PauseAction {
  id              String   @id @default(cuid())

  brfqId          String
  brfq            BRFQ     @relation(fields: [brfqId], references: [id], onDelete: Cascade)

  // optional link back to PauseRequest (if this action was created from a PauseRequest)
  pauseRequestId  String? 
  pauseRequest    PauseRequest? @relation(fields: [pauseRequestId], references: [id], onDelete: Cascade)

  action          String   // "paused" | "resumed" | "pause_requested" | "pause_rejected"
  performedBy     String?
  reasonId        String?
  reasonText      String?
  notifySuppliers Boolean  @default(true)
  createdAt       DateTime @default(now())

  @@index([brfqId])
  @@index([pauseRequestId])
}

model AdminPauseConfig {
  id                     String   @id @default(cuid())
  approvalRequired       Boolean  @default(false) // if true, buyer pause requests create PauseRequest -> admin must approve
  notifyInternalEmails   String[] @default([])     // internal recipients
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

/// ----------------------
/// Award module
/// ----------------------

model AwardWorkflow {
  id                 String   @id @default(cuid())
  name               String   @unique // e.g. "default_award_workflow"
  description        String?
  // flexible place to hold rules and notification mapping
  config             Json
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  createdBy          String?  // optional user id who created this config

  @@map("award_workflows")
}

model Award {
  id               String    @id @default(uuid())
  brfqId           String    @unique // one award record per BRFQ; remove unique if multiple awards allowed
  brfq             BRFQ      @relation(fields: [brfqId], references: [id], onDelete: Cascade)

  status           String    @default("pending") // pending | approved | rejected
  justification    String?
  estimatedValue   Float?
  splitAward       Boolean   @default(false)
  createdBy        String?   // user id
  createdAt        DateTime  @default(now())
  approvedBy       String?
  approvedAt       DateTime?
  note             String?

  winners          AwardWinner[]
  approvals        AwardApprovalHistory[]

  @@map("awards")
}

model AwardWinner {
  id        String  @id @default(cuid())
  award     Award   @relation(fields: [awardId], references: [id], onDelete: Cascade)
  awardId   String
  supplierId String
  amount    Float?
  createdAt DateTime @default(now())

  @@map("award_winners")
}

model AwardApprovalHistory {
  id        String   @id @default(cuid())
  award     Award    @relation(fields: [awardId], references: [id], onDelete: Cascade)
  awardId   String
  action    String   // requested | approved | rejected | escalated
  byUser    String?  // user id or name
  note      String?
  createdAt DateTime @default(now())

  @@map("award_approval_history")
}


